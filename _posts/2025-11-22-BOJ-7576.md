---
title: >-
  [백준/코틀린] 7576번: 토마토
difficulty: 골드 5
categories: [백준, CLASS 3]
tags: [Kotlin, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 최단 경로, 격자 그래프]
description: 2차원 격자를 멀티소스 BFS로 탐색해 최단 거리를 구하는 Kotlin 그래프 탐색 문제입니다.
---

## 링크
[7576번: 토마토](https://www.acmicpc.net/problem/7576)

## 풀이
2차원 격자에서 인접한 토마토로 익음이 전파되는 과정을 **BFS**로 탐색해,\
모든 칸이 익는 데 걸리는 최소 일수를 구하는 문제입니다.

이 문제는 여러 개의 시작점이 존재하므로, <span class="txt_bg">멀티소스 BFS(**Multi-Source BFS**)</span>로 해결할 수 있습니다.\
처음부터 익어 있는 모든 토마토를 깊이 0인 상태로 큐에 넣고 동시에 탐색을 시작하면,\
어떤 칸에 처음 도달하는 시점이 곧 그 칸이 익게 되는 최단 시간이 됩니다.

## 코드
```kotlin
data class State(
    val y: Int,
    val x: Int,
    val d: Int,
)

lateinit var storage: List<MutableList<Int>>
val dy = listOf(-1, 0, 1, 0)
val dx = listOf(0, -1, 0, 1)

fun bfs(n: Int, m: Int) {
    val queue = ArrayDeque<State>()
    var ans = 0

    for (i in 0 until n) {
        for (j in 0 until m) {
            if (storage[i][j] == 1) {
                queue.addLast(State(i, j, 0))
            }
        }
    }
    while (queue.isNotEmpty()) {
        val (cy, cx, cd) = queue.removeFirst()

        ans = maxOf(ans, cd)
        repeat(4) {
            val ny = cy + dy[it]
            val nx = cx + dx[it]
            val nd = cd + 1

            if (ny in 0 until n &&
                nx in 0 until m &&
                storage[ny][nx] == 0
            ) {
                storage[ny][nx] = 1
                queue.addLast(State(ny, nx, nd))
            }
        }
    }

    println(ans.takeIf { storage.flatten().none { it == 0 } } ?: -1)
}

fun main() {
    val (m, n) = readln().split(" ").map { it.toInt() }
    storage = List(n) { readln().split(" ").map { it.toInt() }.toMutableList() }

    bfs(n, m)
}

```

## 연관 문제
- [[백준/코틀린] 7569번: 토마토](https://potato-cuisine.dev/posts/BOJ-7569) - 3차원 BFS
