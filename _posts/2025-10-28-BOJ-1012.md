---
title: >-
  [백준/코틀린] 1012번: 유기농 배추
description: 실버 2
categories: [백준, CLASS 3]
tags: [Kotlin, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색, 격자 그래프, 플러드 필]
---

## 링크
[1012번: 유기농 배추](https://www.acmicpc.net/problem/1012)

## 풀이
<span class="txt_bg">플러드 필(`Flood Fill`) 알고리즘</span>으로 해결할 수 있습니다.\
`DFS` 또는 `BFS`를 사용해 연결된 영역을 탐색합니다.\
모든 격자를 순회하며 연결된 배추 군집의 개수를 셉니다.

## 코드
```kotlin
fun main() = repeat(readln().toInt()) {
    val (m, n, k) = readln().split(" ").map { it.toInt() }
    val field = Array(n) { BooleanArray(m) { false } }
    val stack = ArrayDeque<Pair<Int, Int>>()
    val visited = Array(n) { BooleanArray(m) { false } }
    val dy = listOf(-1, 0, 1, 0)
    val dx = listOf(0, -1, 0, 1)
    var ans = 0

    repeat(k) {
        val (x, y) = readln().split(" ").map { it.toInt() }

        field[y][x] = true
    }

    for (i in 0 until n) {
        for (j in 0 until m) {
            if (field[i][j] && !visited[i][j]) {
                ans++
                visited[i][j] = true
                stack.addLast(i to j)
                while (stack.isNotEmpty()) {
                    val (cy, cx) = stack.removeLast()

                    (0..3).forEach {
                        val ny = cy + dy[it]
                        val nx = cx + dx[it]

                        if (ny in 0 until n && nx in 0 until m && field[ny][nx] && !visited[ny][nx]) {
                            visited[ny][nx] = true
                            stack.addLast(ny to nx)
                        }
                    }
                }
            }
        }
    }

    println(ans)
}

```
