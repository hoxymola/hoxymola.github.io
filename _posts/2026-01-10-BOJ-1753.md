---
title: >-
  [백준/코틀린] 1753번: 최단경로
difficulty: 골드 4
categories: [백준, CLASS 4]
tags: [Kotlin, 그래프 이론, 최단 경로, 데이크스트라]
description: 방향그래프에서 다익스트라(Dijkstra) 알고리즘을 통해 시작점에서 다른 모든 정점으로의 최단 거리를 구하는 Kotlin 최단 경로 문제입니다.
---

## 링크
[1753번: 최단경로](https://www.acmicpc.net/problem/1753)

## 풀이
![dijkstra animation](../assets/1504/Dijkstra_Animation.gif)
_출처: <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Wikipedia: Dijkstra's algorithm</a>_

<span class="txt_bg">다익스트라(`Dijkstra`)</span> 알고리즘을 사용하여\
시작점 `K`에서 모든 정점까지의 최단 거리를 구합니다.

우선순위 큐에서 가장 비용이 작은 정점을 꺼내 최단 거리를 확정하고,\
인접한 정점들을 큐에 추가하는 과정을 반복합니다.\
도달할 수 없는 정점은 `INF`를 출력합니다.

<br>

> 다익스트라 알고리즘의 자세한 설명은 아래 게시글을 확인해주세요.\
> [[백준/코틀린] 1916번: 최소비용 구하기](https://potato-cuisine.dev/posts/BOJ-1916/)
{: .prompt-info }

## 코드
```kotlin
import java.util.*

lateinit var graph: List<MutableList<Pair<Int, Int>>>
lateinit var distance: MutableList<Int>
const val INF = Int.MAX_VALUE

fun dijkstra(start: Int) {
    val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })

    pq.add(start to 0)
    while (pq.isNotEmpty()) {
        val (cur, cd) = pq.poll()

        if (distance[cur] > cd) {
            distance[cur] = cd
            graph[cur].forEach { (next, w) ->
                pq.add(next to cd + w)
            }
        }
    }
}

fun main() = with(StringBuilder()) {
    val (v, e) = readln().split(" ").map { it.toInt() }
    graph = List(v + 1) { mutableListOf() }
    distance = MutableList(v + 1) { INF }
    val k = readln().toInt()

    repeat(e) {
        val (u, v, w) = readln().split(" ").map { it.toInt() }

        graph[u] += v to w
    }

    dijkstra(k)
    distance.drop(1).forEach { appendLine(it.takeIf { it != INF } ?: "INF") }

    println(toString())
}

```
