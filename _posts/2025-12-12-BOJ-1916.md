---
title: >-
  [백준/코틀린] 1916번: 최소비용 구하기
difficulty: 골드 5
categories: [백준, CLASS 4]
tags: [Kotlin, 그래프 이론, 최단 경로, 데이크스트라]
description: 다익스트라(Dijkstra) 알고리즘을 통해 특정 시작점에서 모든 정점까지의 최소 비용을 구하는 Kotlin 최단 경로 문제입니다.
---

## 링크
[1916번: 최소비용 구하기](https://www.acmicpc.net/problem/1916)

## 풀이
그래프의 <span class="txt_bg">특정 시작점으로부터 모든 정점까지의 최단 거리</span>를\
<span class="txt_bg">다익스트라(`Dijkstra`) 알고리즘</span>을 사용하여 구합니다.

우선순위 큐에 **(정점, 지금까지의 비용)**을 넣고,\
가장 비용이 작은 정점부터 꺼내며 최단 거리를 확정한 뒤, 인접한 정점들을 큐에 추가합니다.

음수 가중치가 없는 그래프이기 때문에,\
정점이 처음 큐에서 꺼내질 때의 거리가 반드시 해당 정점까지의 최단 거리입니다.\
<span class="txt_bg">더 짧은 경로가 존재한다면, 그 경로에 포함된 정점이 먼저 선택됐어야 하므로 모순입니다.</span>\
따라서 각 정점은 한 번만 갱신되며, 전체 시간 복잡도는 `O(E log V)`입니다.
- `V`: 정점의 수
- `E`: 간선의 수

<br>

> [[실전 알고리즘] 0x1D강 - 다익스트라 알고리즘](https://blog.encrypted.gg/1037)
{: .prompt-info }

## 코드
```kotlin
import java.util.*

lateinit var graph: List<MutableList<Pair<Int, Int>>>
lateinit var distance: MutableList<Int>

fun dijkstra(start: Int) {
    val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })

    pq.add(start to 0)
    while (pq.isNotEmpty()) {
        val (cur, cd) = pq.poll()

        if (distance[cur] > cd) {
            distance[cur] = cd
            graph[cur].forEach { (next, w) ->
                val nd = cd + w

                pq.add(next to nd)
            }
        }
    }
}

fun main() {
    val n = readln().toInt()
    graph = List(n + 1) { mutableListOf() }
    distance = MutableList(n + 1) { Int.MAX_VALUE }

    repeat(readln().toInt()) {
        val (u, v, w) = readln().split(" ").map { it.toInt() }

        graph[u] += v to w
    }

    val (start, end) = readln().split(" ").map { it.toInt() }

    dijkstra(start)

    println(distance[end])
}

```
