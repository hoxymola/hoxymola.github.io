---
title: >-
  [백준/코틀린] 11053번: 가장 긴 증가하는 부분 수열
difficulty: 실버 2
categories: [백준, CLASS 4]
tags: [Kotlin, 다이나믹 프로그래밍, 가장 긴 증가하는 부분 수열 문제]
description: 이중 반복문을 통해 가장 긴 증가하는 부분 수열(LIS)의 길이를 구하는 Kotlin DP 문제입니다.
---

## 링크
[11053번: 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)

## 풀이
<span class="txt_bg">LIS(`Longest Increasing Subsequence`)</span>란?\
주어진 수열에서 원소의 순서를 유지하면서 선택한 부분 수열 중,\
원소가 순증가하는 가장 긴 수열을 말합니다.\
예를 들어 `[10, 20, 10, 30, 20, 50]`의 LIS는 `[10, 20, 30, 50]`으로 길이 4입니다.

<span class="txt_bg">`dp[i]`: `i`번째 원소를 마지막으로 하는 LIS의 길이</span>

`j < i`인 인덱스에 대해 `a[j] < a[i]`인 경우,\
<span class="txt_bg">`j`에서 끝나는 LIS 뒤에 `a[i]`를 이어 붙일 수 있으므로</span> `dp[i]`를 갱신합니다.

문제의 조건이 `N ≤ 1,000`이므로, 이중 반복문을 사용해 `O(n²)`로 해결할 수 있습니다.

> `N`이 크면 (`N ≤ 100,000`) 이분 탐색을 활용한 `O(n log n)` 풀이가 필요합니다.
{: .prompt-tip }

## 코드
```kotlin
fun main() {
    val n = readln().toInt()
    val a = readln().split(" ").map { it.toInt() }
    val dp = MutableList(n) { 1 }

    for (i in 0 until n) {
        for (j in 0 until i) {
            if (a[j] < a[i]) {
                dp[i] = maxOf(dp[i], dp[j] + 1)
            }
        }
    }

    println(dp.maxOrNull())
}

```
