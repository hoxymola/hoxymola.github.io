---
title: >-
  [백준/코틀린] 11404번: 플로이드
difficulty: 골드 4
categories: [백준, CLASS 4]
tags: [Kotlin, 그래프 이론, 최단 경로, 플로이드-워셜]
description: 플로이드-워셜 알고리즘으로 모든 도시 쌍 간의 최소 이동 비용을 구하는 Kotlin 그래프 최단 경로 문제입니다.
---

## 링크
[11404번: 플로이드](https://www.acmicpc.net/problem/11404)

## 풀이
<span class="txt_bg">플로이드-워셜(`Floyd–Warshall`) 알고리즘</span>으로 모든 도시 쌍 간의 최소 비용을 구합니다.

중간 도시 `k`를 경유하는 경로 `graph[i][k] + graph[k][j]`가\
기존 경로 `graph[i][j]`보다 짧으면 갱신하는 과정을 모든 `k`에 대해 반복합니다.

<br>

> [[실전 알고리즘] 0x1C강 - 플로이드 알고리즘](https://blog.encrypted.gg/1035)
{: .prompt-info }

## 코드
```kotlin
const val MAX = Int.MAX_VALUE / 2
fun main() {
    val n = readln().toInt()
    val m = readln().toInt()
    val graph = List(n) { r -> MutableList(n) { c -> if (r == c) 0 else MAX } }

    repeat(m) {
        val (u, v, w) = readln().split(" ").map { it.toInt() }

        graph[u - 1][v - 1] = minOf(graph[u - 1][v - 1], w)
    }

    for (k in 0 until n) {
        for (i in 0 until n) {
            for (j in 0 until n) {
                graph[i][j] = minOf(graph[i][j], graph[i][k] + graph[k][j])
            }
        }
    }

    graph.forEach { row ->
        println(row.map { if (it == MAX) 0 else it }.joinToString(" "))
    }
}

```

## 연관 문제
- [[백준/코틀린] 1389번: 케빈 베이컨의 6단계 법칙](https://potato-cuisine.dev/posts/BOJ-1389/)
- [[백준/코틀린] 11403번: 경로 찾기](https://potato-cuisine.dev/posts/BOJ-11403/)
- [[백준/코틀린] 14938번: 서강그라운드](https://potato-cuisine.dev/posts/BOJ-14938/)
