---
title: >-
  [백준/코틀린] 15663번: N과 M (9)
difficulty: 실버 2
categories: [백준, CLASS 4]
tags: [Kotlin, 백트래킹]
description: 주어진 N개의 자연수 중에서 M개를 선택해 중복 없는 순열을 생성하는 Kotlin 백트래킹 문제입니다.
---

## 링크
[15663번: N과 M (9)](https://www.acmicpc.net/problem/15663)

## 풀이
주어진 `N`개의 자연수 중에서 `M`개를 선택해 <span class="txt_bg">중복 없는 순열</span>을 만드는 백트래킹 문제입니다.\
`N`개의 자연수는가 중복될 수 있기 때문에, 중복된 수열이 생성되지 않도록 중복 처리 과정이 필요합니다.

입력으로 주어지는 숫자를 오름차순으로 정렬한 뒤, 백트래킹으로 길이 `M`의 수열을 채워 나갑니다.\
`visited` 배열로 동일한 인덱스를 다시 선택하지 않도록 하고,\
`last` 변수를 사용해 같은 재귀 단계(`depth`)에서 <span class="txt_bg">동일한 숫자를 중복 선택하는 것을 방지</span>합니다.
- `d`: 재귀의 깊이(현재까지 채운 수열의 길이)

## 코드
```kotlin
lateinit var nums: List<Int>
lateinit var sequence: IntArray
lateinit var visited: BooleanArray

fun backtrack(n: Int, m: Int, d: Int) {
    if (m == d) return println(sequence.joinToString(" "))
    
    var last = -1

    nums.forEachIndexed { i, num ->
        if (!visited[i] && last != num) {
            visited[i] = true
            last = num
            sequence[d] = num
            backtrack(n, m, d + 1)
            visited[i] = false
        }
    }
}

fun main() {
    val (n, m) = readln().split(" ").map { it.toInt() }
    nums = readln().split(" ").map { it.toInt() }.sorted()
    sequence = IntArray(m)
    visited = BooleanArray(n)

    backtrack(n, m, 0)
}

```

## 연관 문제
- [[백준/코틀린] 15650번: N과 M (2)](https://potato-cuisine.dev/posts/BOJ-15650) - 조합
- [[백준/코틀린] 15652번: N과 M (4)](https://potato-cuisine.dev/posts/BOJ-15652) - 중복 조합
- [[백준/코틀린] 15654번: N과 M (5)](https://potato-cuisine.dev/posts/BOJ-15654) - 순열
