---
title: >-
  [백준/코틀린] 1389번: 케빈 베이컨의 6단계 법칙
difficulty: 실버 1
categories: [백준, CLASS 3]
tags: [Kotlin, 그래프 이론, 그래프 탐색, 최단 경로, 플로이드-워셜]
description: 플로이드–워셜(Floyd–Warshall) 알고리즘으로 모든 사람 간 최단 거리를 계산해 케빈 베이컨 수가 가장 작은 사람을 찾는 Kotlin 그래프 최단 경로 문제입니다.
---

## 링크
[1389번: 케빈 베이컨의 6단계 법칙](https://www.acmicpc.net/problem/1389)

## 풀이

<span class="txt_bg">플로이드-워셜(`Floyd–Warshall`) 알고리즘</span>을 사용해 그래프의 모든 노드 쌍에 대한 최단 거리를 구합니다. 

임의의 노드 `i`에서 `j`로 가는 최단 거리 `d[i][j]`를 계산하기 위해,\
`i`와 `j`사이의 중간 노드 `k`를 경유하는 모든 경로 `d[i][k] + d[k][j]`를 고려합니다.

<br>

> [[실전 알고리즘] 0x1C강 - 플로이드 알고리즘](https://blog.encrypted.gg/1035)
{: .prompt-info }

## 코드
```kotlin
fun main() {
    val (n, m) = readln().split(" ").map { it.toInt() }
    val graph = List(n + 1) { r -> MutableList(n + 1) { c -> if (r == c) 0 else Int.MAX_VALUE / 101 } }

    repeat(m) {
        val (a, b) = readln().split(" ").map { it.toInt() }

        graph[a][b] = 1
        graph[b][a] = 1
    }

    for (k in 1..n) {
        for (i in 1..n) {
            for (j in 1..n) {
                graph[i][j] = minOf(graph[i][j], graph[i][k] + graph[k][j])
            }
        }
    }

    println((1..n).minByOrNull { graph[it].sum() })
}

```
