---
title: >-
  [백준/코틀린] 21736번: 헌내기는 친구가 필요해
difficulty: 실버 2
categories: [백준, CLASS 3]
tags: [Kotlin, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색, 격자 그래프]
description: 시작 위치에서 DFS 또는 BFS로 이동 가능한 모든 칸을 탐색해 만날 수 있는 사람의 수를 세는 Kotlin 그래프 탐색 문제입니다.
---

## 링크
[21736번: 헌내기는 친구가 필요해](https://www.acmicpc.net/problem/21736)

## 풀이
도연이의 위치에서 시작해, `DFS` 또는 `BFS`로 이동 가능한 모든 칸을 탐색해 만날 수 있는 사람의 수를 셉니다.

## 코드
```kotlin
lateinit var campus: List<String>
lateinit var visited: Array<BooleanArray>
val stack = ArrayDeque<Pair<Int, Int>>()
val dy = listOf(-1, 0, 1, 0)
val dx = listOf(0, 1, 0, -1)
var ans = 0

fun dfs(n: Int, m: Int, sy: Int, sx: Int) {
    visited[sy][sx] = true
    stack.addLast(sy to sx)
    while (stack.isNotEmpty()) {
        val (cy, cx) = stack.removeLast()

        if (campus[cy][cx] == 'P') ans++
        repeat(4) {
            val ny = cy + dy[it]
            val nx = cx + dx[it]

            if (ny in 0 until n &&
                nx in 0 until m &&
                campus[ny][nx] != 'X' &&
                !visited[ny][nx]
            ) {
                visited[ny][nx] = true
                stack.addLast(ny to nx)
            }
        }
    }
}

fun main() {
    val (n, m) = readln().split(" ").map { it.toInt() }
    campus = List(n) { readln() }
    visited = Array(n) { BooleanArray(m) }
    val (y, x) = campus.joinToString("")
        .indexOf('I').let { (it / m) to (it % m) }

    dfs(n, m, y, x)

    println(ans.takeIf { it > 0 } ?: "TT")
}

```
