---
title: >-
  [백준/코틀린] 16953번: A → B
difficulty: 실버 2
categories: [백준, CLASS 4]
tags: [Kotlin, 그래프 이론, 그리디 알고리즘, 그래프 탐색, 너비 우선 탐색]
description: A를 B로 바꾸는 데 필요한 최소 연산 횟수를 BFS 또는 그리디 알고리즘으로 구하는 Kotlin 문제입니다.
---

## 링크
[16953번: A → B](https://www.acmicpc.net/problem/16953)

## 개요
`A`를 `B`로 바꾸는 데 필요한 최소 연산 횟수를 두 가지 방식으로 구현합니다.
- [풀이 1: BFS](#풀이-1-bfs)
- [풀이 2: Greedy Algorithm](#풀이-2-greedy-algorithm)

<br>

## 풀이 1: BFS
`A`와 `B` 사이의 모든 숫자를 그래프의 정점으로 보고,\
각 숫자에서 주어진 연산을 통해 이동할 수 있는 상태를 그래프의 간선으로 본다면,\
시작 숫자에서 목표 숫자로 가는 최단 거리를 구하는 `BFS` 문제로 볼 수 있습니다.

<span class="txt_bg">`BFS`를 통해 `A`에서 `B`까지의 최단거리를 구합니다.</span>

<br> 

> 두 연산의 결과는 항상 다른 값을 만들기 때문에, 정점을 이미 방문했는지 체크할 필요가 없습니다.
{: .prompt-tip }

## 코드
```kotlin
val mul = listOf(2, 10)
val add = listOf(0, 1)

fun bfs(start: Long, target: Long) {
    val queue = ArrayDeque<Pair<Long, Int>>()

    queue.addLast(start to 0)
    while (queue.isNotEmpty()) {
        val (current, depth) = queue.removeFirst()

        if (current == target) return println(depth + 1)
        repeat(2) {
            val next = mul[it] * current + add[it]

            if (next <= target) {
                queue.addLast(next to depth + 1)
            }
        }
    }

    println(-1)
}

fun main() {
    val (a, b) = readln().split(" ").map { it.toLong() }

    bfs(a, b)
}

```

<br>

## 풀이 2: Greedy Algorithm
두 연산 모두 값을 증가시키는 방향으로만 진행되기 때문에,\
정방향(`A → B`)에서는 분기가 생기지만 역방향(`B → A`)에서는 분기가 존재하지 않습니다.\
즉, <span class="txt_bg">역방향에서는 매 순간 적용할 수 있는 연산이 최대 하나</span>뿐입니다.

`B`의 마지막 자리가 `1`이라면 뒤의 `1`을 제거하고,\
그렇지 않고 `B`가 짝수라면 `2`로 나눕니다.

<span class="txt_bg">그리디한 방식으로 `B`를 `A`로 바꾸는데 필요한 연산의 최솟값을 구합니다.</span>

## 코드
```kotlin
fun main() {
    var (a, b) = readln().split(" ").map { it.toLong() }
    var ans = 0

    while (true) {
        when {
            a == b -> return println(ans + 1)
            a > b -> return println(-1)
            b % 10 == 1L -> b /= 10
            b % 2 == 0L -> b /= 2
            else -> return println(-1)
        }
        ans++
    }
}

```
