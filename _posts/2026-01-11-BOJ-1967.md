---
title: >-
  [백준/코틀린] 1967번: 트리의 지름
difficulty: 골드 4
categories: [백준, CLASS 4]
tags: [Kotlin, 그래프 이론, 그래프 탐색, 트리, 깊이 우선 탐색, 트리의 지름]
description: 두 번의 DFS를 통해 트리의 지름을 구하는 Kotlin 그래프 탐색 문제입니다.
---

## 링크
[1967번: 트리의 지름](https://www.acmicpc.net/problem/1967)

## 풀이
<span class="txt_bg">트리의 지름</span>은 트리에서 존재하는 모든 경로 중 가장 긴 경로의 길이입니다.

![diameter of a tree.png](../assets/1967/diameter%20of%20a%20tree.png)
_트리의 지름_

트리는 사이클이 없고 모든 정점이 연결되어 있으므로,\
두 정점 사이의 경로는 항상 하나로 결정됩니다.\
따라서 <span class="txt_bg">`DFS` 또는 `BFS`로 누적 거리를 계산하면, 각 정점까지의 거리를 구할 수 있습니다.</span>

임의의 정점에서 가장 먼 정점을 `A`라고 하면,\
`A`는 반드시 지름의 한 끝점이 됩니다.\
그리고 `A`에서 가장 먼 정점 `B`를 구하게 되면,\
두 정점 `A`와 `B`는 트리 지름의 양 끝점이 됩니다.

즉, <span class="txt_bg">두 번의 탐색을 통해 트리의 지름을 구할 수 있습니다.</span>

## 코드
```kotlin
var n = 0
lateinit var graph: List<MutableList<Pair<Int, Int>>>
lateinit var distance: IntArray
lateinit var visited: BooleanArray

fun dfs(start: Int): Int {
    val stack = ArrayDeque<Pair<Int, Int>>()
    distance = IntArray(n + 1)
    visited = BooleanArray(n + 1)
    var (max, index) = 0 to 0

    visited[start] = true
    stack.addLast(start to 0)
    while (stack.isNotEmpty()) {
        val (cur, cd) = stack.removeLast()

        distance[cur] = cd
        if (max < cd) {
            max = cd
            index = cur
        }
        graph[cur].forEach {
            val next = it.first
            val nd = it.second + cd

            if (!visited[next]) {
                visited[next] = true
                stack.addLast(next to nd)
            }
        }
    }

    return index
}

fun main() {
    n = readln().toInt()
    graph = List(n + 1) { mutableListOf() }

    repeat(n - 1) {
        val (u, v, w) = readln().split(" ").map { it.toInt() }

        graph[u] += v to w
        graph[v] += u to w
    }

    val a = dfs(1)
    val b = dfs(a)

    println(distance[b])
}

```
