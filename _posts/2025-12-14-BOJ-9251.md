---
title: >-
  [백준/코틀린] 9251번: LCS
difficulty: 골드 5
categories: [백준, CLASS 4]
tags: [Kotlin, 다이나믹 프로그래밍, 문자열, 최장 공통 부분 수열 문제]
description: 두 문자열의 LCS(Longest Common Subsequence, 최장 공통 부분 수열)의 길이를 구하는 Kotlin DP 문제입니다.
---

## 링크
[9251번: LCS](https://www.acmicpc.net/problem/9251)

## 풀이
<span class="txt_bg">`dp[i][j]`: 첫 번째 문자열(`A`)의 `i`번째 문자와 두 번째 문자열(`B`)의 `j`번째 문자까지의 `LCS` 길이</span>

![lcs example](../assets/9251/lcs%20light.png){: .light }
![lcs example](../assets/9251/lcs%20dark.png){: .dark }
_출처: <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence">Wikipedia: Longest common subsequence</a>_

만약 `A`의 `i`번째 문자와 `B`의 `j`번째 문자가 같다면,\
<span class="txt_bg">이는 `A`의 `i-1`번째 문자와 `B`의 `j-1`번째 문자까지의 `LCS`에 해당 문자를 추가한 것과 같습니다.</span>\
`dp[i][j] = dp[i-1][j-1] + 1`

<br>

`A`의 `i`번째 문자와 `B`의 `j`번째 문자가 다르다면,\
<span class="txt_bg">두 문자를 동시에 사용하는 공통 부분 수열은 만들 수 없으므로</span>,\
`A`에서 문자를 하나 제외하거나 `B`에서 문자를 하나 제외한 경우를 고려합니다.

즉, `A`의 `i-1`번째 문자와 `B`의 `j`번째 문자까지의 `LCS`,  
또는 `A`의 `i`번째 문자와 `B`의 `j-1`번째 문자까지의 `LCS` 중 더 긴 쪽을 선택합니다.  
`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

## 코드
```kotlin
fun main() {
    val a = readln()
    val n = a.length
    val b = readln()
    val m = b.length
    val dp = Array(n + 1) { IntArray(m + 1) }

    for (i in 1..n) {
        for (j in 1..m) {
            dp[i][j] = if (a[i - 1] == b[j - 1]) dp[i - 1][j - 1] + 1
            else maxOf(dp[i - 1][j], dp[i][j - 1])
        }
    }

    println(dp[n][m])
}

```
