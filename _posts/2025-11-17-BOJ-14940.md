---
title: >-
  [백준/코틀린] 14940번: 쉬운 최단거리
difficulty: 실버 1
categories: [백준, CLASS 3]
tags: [Kotlin, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 격자 그래프]
description: 목표 지점에서 BFS를 시작해 각 위치까지의 최단 거리를 계산하는 Kotlin 격자형 그래프 탐색 문제입니다.
---

## 링크
[14940번: 쉬운 최단거리](https://www.acmicpc.net/problem/14940)

## 풀이
목표 지점에서 `BFS`를 시작해 이동할 수 있는 각 지점까지의 최단 거리를 계산합니다.

## 코드
```kotlin
data class State(
    val y: Int,
    val x: Int,
    val d: Int,
)

lateinit var map: List<List<Int>>
lateinit var visited: Array<BooleanArray>
lateinit var dist: List<MutableList<Int>>
val dy = listOf(-1, 0, 1, 0)
val dx = listOf(0, 1, 0, -1)

fun bfs(n: Int, m: Int, sy: Int, sx: Int) {
    val queue = ArrayDeque<State>()

    visited[sy][sx] = true
    queue.addLast(State(sy, sx, 0))
    while (queue.isNotEmpty()) {
        val (cy, cx, cd) = queue.removeFirst()

        dist[cy][cx] = cd
        repeat(4) {
            val ny = cy + dy[it]
            val nx = cx + dx[it]
            val nd = cd + 1

            if (ny in 0 until n &&
                nx in 0 until m &&
                map[ny][nx] != 0 &&
                !visited[ny][nx]
            ) {
                visited[ny][nx] = true
                queue.addLast(State(ny, nx, nd))
            }
        }
    }
}

fun main() {
    val (n, m) = readln().split(" ").map { it.toInt() }
    map = List(n) { readln().split(" ").map { it.toInt() } }
    visited = Array(n) { BooleanArray(m) }
    dist = List(n) { i -> MutableList(m) { j -> if (map[i][j] == 0) 0 else -1 } }
    val (sy, sx) = map.flatten().indexOfFirst { it == 2 }
        .let { it / m to it % m }

    bfs(n, m, sy, sx)

    dist.forEach { println(it.joinToString(" ")) }
}

```
